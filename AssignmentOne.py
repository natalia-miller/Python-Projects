# Natalia Miller

'''
The following code has been adapted from psuedocode:
    I. Millington, Artificial Intelligence for Games, Third Edition,
    CRC Press, Boca Raton FL, 2019
''' 

import math

output_file = r"output.txt"



#------------------------------------------------------------------------------#
#                               Vector Functions                               #
#------------------------------------------------------------------------------#
def length(vector):
    length = math.sqrt((vector[0]*vector[0]) + (vector[1]*vector[1]))
    return length

def normalize(vector):
    '''
    Normalizes a vector
    '''
    magnitude = length(vector)

    if (len(vector) != 0 and magnitude != 0):
        normalized_x = vector[0] / magnitude
        normalized_z = vector[1] / magnitude
        return [normalized_x, normalized_z]
    else:
        return [0,0]
    

#------------------------------------------------------------------------------#
#                              Movement Functions                              #
#------------------------------------------------------------------------------#
def steering_update(character):
    ''' Updates characterâ€™s movement variables
        - Outputs: New values for position, orientation, velocity, rotation
        - Inputs: linear and angular accelerations
        - Inputs generated by movement behaviors
    '''
    position = character["position"]
    if not position:
        position = [0,0]
    velocity = character["velocity"]
    if not velocity:
        velocity = [0,0]
    orientation = character["orientation"]
    rotation = 0
    angular = [0,0]
    max_velocity = character["max_velocity"]
    time = character["timestep"]
    character_id = character["id"]
    linear_acceleration = character["linear_acceleration"]
    if not linear_acceleration:
        linear_acceleration = [0,0]

    # Update the position and orientation  
    position[0] += velocity[0] * time  
    position[1] += velocity[1] * time  
    orientation += rotation * time  

    # Update the velocity and rotation  
    velocity[0] += linear_acceleration[0] * time  
    velocity[1] += linear_acceleration[1] * time  
    rotation += angular[0] * time  

    # Check for speed above max and clip 
    if length(velocity) > max_velocity:
        normalized_velocity = normalize(velocity)
        normalized_velocity *= max_velocity
        velocity = normalized_velocity
    
    # Update character position, orientation, and velocity
    if (character_id == 2601):
        character_1["position"] = position
        character_1["orientation"] = orientation
        character_1["velocity"] = velocity
    if (character_id == 2603):
        character_3["position"] = position
        character_3["orientation"] = orientation
        character_3["velocity"] = velocity


def get_steering_continue(character):
    # Continue moving without changing velocity or orientation
    result = character["velocity"]
    return result


def get_steering_seek(character, target):
    character_position = character["position"]
    target_position = target["position"]
    max_acceleration = character["max_acceleration"]
    linear_result = [0, 0]

    # Get the direction to the target
    linear_result[0] = target_position[0] - character_position[0]
    linear_result[1] = target_position[1] - character_position[1]

    # Accelerate at maximum rate
    linear_result = normalize(linear_result)
    linear_result[0] *= max_acceleration
    linear_result[1] *= max_acceleration

    # Output steering
    return linear_result


def get_steering_flee(character, target):
    character_position = character["position"]
    target_position = target["position"]
    max_acceleration = character["max_acceleration"]
    linear_result = [0, 0]

    # Get the direction to the target
    linear_result[0] =  character_position[0] - target_position[0]
    linear_result[1] =  character_position[1] - target_position[1]

    # Accelerate at maximum rate
    linear_result = normalize(linear_result)
    linear_result[0] *= max_acceleration
    linear_result[1] *= max_acceleration

    # Output steering
    return linear_result[0], linear_result[1]


def get_steering_arrive(character, target):
    character_position = character["position"]
    target_position = target["position"]
    max_acceleration = character["max_acceleration"]
    target_radius = character["arrival_radius"]
    slow_radius = character["slowing_radius"]
    time_to_target = character["time_to_target"]
    character_velocity = character["velocity"]
    target_speed = 0
    linear_result = [0, 0]
    
    direction = target_position - character_position
    distance = length(direction)
    # max_speed = length / time_to_target
    max_speed = character["max_velocity"]

    # Test for arrival
    if distance < target_radius:
        # return None
        target_speed = 0

    # Outside slowing-down (outer) radius, move at max speed
    if distance > slow_radius:
        target_speed = max_speed
    # Between radii, scale speed to slow down
    else:
        target_speed = max_speed * distance / slow_radius

    # Target velocity combines speed and direction
    target_velocity = direction
    target_velocity = normalize(target_velocity)
    target_velocity *= target_speed

    # Accelerate to target velocity
    linear_result = target_velocity - character_velocity
    linear_result[0] /= time_to_target
    linear_result[1] /= time_to_target

    # Test for too fast acceleration
    if length(linear_result) > max_acceleration:
        linear_result = normalize(linear_result)
        linear_result[0] *= max_acceleration
        linear_result[1] *= max_acceleration

    # Output steering
    return linear_result


def output_steering(character):
    position = character["position"]
    velocity = character["velocity"]
    if not velocity: 
        velocity = [0, 0]
    linear_acceleration = character["linear_acceleration"]
    if not linear_acceleration: 
        linear_acceleration = [0, 0]
    
    # Output formatted information to file
    with open(output_file, "a") as f:
        print('{},'.format(character["timestep"]) +
            '{},'.format(character["id"]) +
            '{},'.format(position[0]) +
            '{},'.format(position[1]) +
            '{},'.format(velocity[0]) +
            '{},'.format(velocity[1]) +
            '{},'.format(linear_acceleration[0]) +
            '{},'.format(linear_acceleration[1]) +
            '{},'.format(character["orientation"]) +
            '{},'.format(character["steering_behavior_code"]) +
            '{}'.format(character["collision_status"]), file = f)

#------------------------------------------------------------------------------#
#                           Character Initializations                          #
#------------------------------------------------------------------------------#
character_1 = {
    "id": 2601,
	"steering_behavior": "Continue",
    "steering_behavior_code": "1",
    "inital_position": [0, 0],
	"inital_velocity": [0, 0],
	"inital_orientation": 0,
	"max_velocity": 0,
	"max_acceleration": 0,
	"target": 0,				 
    "arrival_radius": 0,
    "slowing_radius": 0,
    "time_to_target": 0,
    "timestep": 0,
    "velocity": [0, 0],
    "linear_acceleration": [0, 0],
    "acceleration": 0,
    "orientation": 0,
    "collision_status": False,
    "position": [0, 0],
}


character_2 = {
	"id": 2602,
	"steering_behavior": "Flee",
    "steering_behavior_code": "7",
	"inital_position": [-30, -50],
	"inital_velocity": [2.0, 7.0],
	"inital_orientation": math.radians(45),
	"max_velocity": 8,
	"max_acceleration": 1.5,
    "target": 1,				 
    "arrival_radius": 0,
    "slowing_radius": 0,
    "time_to_target": 0,		
    "timestep": 0,
    "position": [-30, -50],
    "velocity": [2, 7],
    "linear_acceleration": [0, 0],
    "acceleration": 0,
    "orientation": math.radians(45),
    "collision_status": False,
}


character_3 = {
	"id": 2603,
	"steering_behavior": "Seek",
    "steering_behavior_code": "6",
	"inital_position":[-50, 40],
	"inital_velocity": [0, 8],
	"inital_orientation": math.radians(270),
	"max_velocity": 8,
	"max_acceleration": 2,
	"target": 1,				 
    "arrival_radius": 0,
    "slowing_radius": 0,
    "time_to_target": 0,
    "timestep": 0,
    "velocity": [0, 8],
    "linear_acceleration": [0, 0],
    "acceleration": 0,
    "orientation": math.radians(270),
    "collision_status": False,
    "position": [-50, 40],
}


character_4 = {
	"id": 2604,
	"steering_behavior": "Arrive",
    "steering_behavior_code": "8",
	"inital_position": [50, 75],
	"inital_velocity": [-9, 4],
	"inital_orientation": math.radians(180),
	"max_velocity": 10,
	"max_acceleration": 2,
	"target": 1,				 
    "arrival_radius": 4,
    "slowing_radius": 32,
    "time_to_target": 1,
    "timestep": 0,
    "position": [50, 75],
    "velocity": [-9, 4],
    "linear_acceleration": [0, 0],
    "acceleration": 0,
    "orientation": math.radians(180),
    "collision_status": False			 
}


#------------------------------------------------------------------------------#
#                                 Main Method                                  #
#------------------------------------------------------------------------------#

# Print initial values
output_steering(character_1)
output_steering(character_2)
output_steering(character_3)
output_steering(character_4)

for x in range(8):

    # Increase timestep by 0.5
    character_1["timestep"] += 0.5
    character_2["timestep"] += 0.5
    character_3["timestep"] += 0.5
    character_4["timestep"] += 0.5

    # Call the character's steering movement behavior
    character_1["linear_acceleration"] = get_steering_continue(character_1)
    character_2["linear_acceleration"] = get_steering_flee(character_2, character_1)
    character_3["linear_acceleration"] = get_steering_seek(character_3, character_1)
    character_4["linear_acceleration"] = get_steering_seek(character_4, character_1)

    # Update the character's postion, orientation, and velocity
    steering_update(character_1)
    steering_update(character_2)
    steering_update(character_3)
    steering_update(character_4)

    # Print updated values
    output_steering(character_1)
    output_steering(character_2)
    output_steering(character_3)
    output_steering(character_4)
