#!/usr/bin/env python3


# TODO: Define kinematic type??
# TODO: Get function definitons from slide
'''
Seek; move directly towards target as fast as possible.
Flee;  move directly away from target as fast as possible.
Arrive; move directly towards target, slowing down when near.
'''
# TODO: See 1 Support r file for vector class example
# TODO: Need normalize function
'''
The NumPy module in Python has the linalg.norm() function that can return the array’s 
vector norm. Then we divide the array with this norm vector to get the normalized 
vector. For example, in the code below, we will create a random array and find its 
normalized form using this method.

v = np.random.rand(10)
normalized_v = v / np.linalg.norm(v)
print(normalized_v)
'''

'''
When writing normalization function, we need to check for a magnitude of zero, 
bc we can't divid by zero. 

Javascript code from Khan Academy: 
https://www.khanacademy.org/computing/computer-programming/programming-natural-simulations/programming-vectors/a/vector-magnitude-normalization

PVector.prototype.normalize = function() {
  var m = this.mag();
  if (m > 0) {
    this.div(m);
  }
};

'''

# Natalia Miller

''' The following code has been adapted from psuedocode:
    I. Millington, Artificial Intelligence for Games, Third Edition,
    CRC Press, Boca Raton FL, 2019
'''
import math
import numpy as np 
from matplotlib import pyplot as plt

'''
10 int values, 1 bool value in vector for plotting
1. simulation time
2. character id (numeric)
3. position x (meters)
4. position z (meters)
5. velocity x (meters per second)
6. velocity z (meters per second)
7. linear acceleration x (meters per second per second)
8. linear acceleration z (meters per second per second)
9. orientation (radians)
10. steering behavior code (1=Continue, 6=Seek, 7=Flee, 8=Arrive)
11. collision status (TRUE if collided, FALSE if not collided; always FALSE for Program 1)
'''

#------------------------------------------------------------------------------#
#                              Steering Behaviors                              #
#------------------------------------------------------------------------------#
class SteeringOutput:
  ''' 
   Inputs to steering behaviors:
    - Character data (position, orientation)  
    - Target data needed for steering behavior (e.g., position, velocity)  
   Outputs from steering behaviors:
    - Linear acceleration (vector, rate of change of velocity)  
    - Angular acceleration (scalar, rate of change of rotation)  
  '''
  def __init__(self):
    '''
     Args:
      linear: linear acceleration -> vector
      angular: angular acceleration, scalar -> float
    '''
    self.linear = 0 
    self.angular = 0

# TODO: Does this belong in a class?
def update(steering: SteeringOutput, max_speed: float, time: float):
  ''' Updates character’s movement variables
      - Outputs: New values for position, orientation, velocity, rotation
      - Inputs: linear and angular accelerations
      - Inputs generated by movement behaviors
  '''
	# Update the position and orientation  
  position += velocity * time  
  orientation += rotation * time  

	# Update the velocity and rotation  
  velocity += steering.linear * time  
  rotation += steering.angular * time  

  # Check for speed above max and clip  
  if velocity.length() > max_speed:  
    velocity.normalize()  
    velocity *= max_speed

#------------------------------------------------------------------------------#
#                              Movement Behaviors                              #
#------------------------------------------------------------------------------#

class DynamicSeek:
  ''' 
  Seek: Match character position to target position
    - Determine direction to target
    - Accelerate in that direction at max rate up to max speed
  '''
  def __init__(self):
    '''
    Args:
      character: position and orientation for character -> kinematic
      target: position and orientation for target -> kinematic
      max_acceleration: maximum acceleration rate for character -> float 
    '''
    self.character = 0 
    self.target = 0
    self.max_acceleration = 0 

  def get_steering(self) -> SteeringOutput:
    # Create output structure
    result = SteeringOutput()

    # Get the direction to the target
    result.linear = self.target.position - self.character.position

    # Accelerate at maximum rate
    result.linear.normalize()
    result.linear *= self.max_acceleration

    # Output steering
    result.angular = 0
    return result

class DynamicFlee:
  ''' 
  Flee: Negate character position to target position
    - Determine direction to target
    - Accelerate in opposite direction at max rate up to max speed
  '''
  def __init__(self):
    '''
    Args:
      character: position and orientation for character -> kinematic
      target: position and orientation for target -> kinematic
      max_acceleration: maximum acceleration rate for character -> float 
    '''
    self.character = 0 
    self.target = 0
    self.max_acceleration = 0 

  def getSteering(self) -> SteeringOutput:
    # Create output structure
    result = SteeringOutput()

    # Get the direction to the target
    result.linear = self.character.position - self.target.position

    # Accelerate at maximum rate
    result.linear.normalize()
    result.linear *= self.max_acceleration

    # Output steering
    result.angular = 0
    return result

class DynamicArrive:
  ''' 
  Arrive: Uses two distance raddii to solve the issue that accelerating
  at max rate to max speed causes, i.e. overshooting or orbiting target
    - Slowing-down radius; distance to target below -> character slows down
    - Arrival radius; distance to target below -> character stops
  Direction
    - Desired direction calculated directly toward target
  Speed
    - Outside slowing-down radius, desired speed set to max speed
    - Between radii, desired speed interpolated between max and 0
    - Inside arrival radius, desired speed set to 0
  Velocity
    - Direction and speed combined to give desired velocity
    - Acceleration set to change current velocity to desired velocity  
  '''
  def __init__(self):
    '''
    Args:
      character: position and orientation for character -> Kinematic        
      target: position and orientation for target -> Kinematic          
      maxAcceleration: maximum acceleration rate for character-> float
      maxSpeed: maximum speed for character -> float            
      targetRadius: arrival radius -> float         
      slowRadius: slowing-down radius -> float          
      timeToTarget: time over which to achieve target speed -> float = 0.1 
    '''
    self.character = 0
    self.target = 0
    self.max_acceleration = 0
    self.max_speed = 0
    self.target_radius = 0
    self.slow_radius = 0
    self.time_to_target = 0

  def getSteering(self) -> SteeringOutput:
    result = SteeringOutput()

    # Get the direction and distance to the target
    direction = self.target.position - self.character.position
    distance = direction.length()
    # Test for arrival
    if distance < self.target_radius:
      return None

    # Outside slowing-down (outer) radius, move at max speed
    if distance > self.slow_radius:
      target_speed = self.max_speed

    # Between radii, scale speed to slow down
    else:
      self.targetSpeed = self.max_speed * distance / self.slow_radius

    # Target velocity combines speed and direction
    target_velocity = direction
    target_velocity.normalize()
    target_velocity *= target_speed

    # Accelerate to target velocity
    result.linear = target_velocity - self.character.velocity
    result.linear /= self.time_to_target

    # Test for too fast acceleration
    if result.linear.length() > self.max_acceleration:
      result.linear.normalize()
      result.linear *= self.max_acceleration

    # Output steering
    result.angular = 0
    return result
